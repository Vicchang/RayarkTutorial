# Week 3 C#
---
* ## What’s different between struct and class?

  Category                     | Struct    | Class 
  -----------------------------|-----------|-----------------------------------
  Parameterless Constructor    | No        | Yes 
  Type                         | Value     | Reference 
  Sealed                       | Default   | Optional 
  Abstract                     | No        | Yes
  Inheritance                  | Interface | Interface, Class, Abstract Class
  Dispose                      | No        | Yes
    
  1. Struct can't have explicit parameterless constrcutor.
  2. Struct is value type. Class is reference type.
  3. Struct can't be abstract. Class can be abstract.
  4. Struct is sealed type as default. Class can be delcared as sealed type.
  5. Struct can't inheritance. Class can inheritance.
  6. Struct can't dipose. Class can dipose.
  7. Struct support interface. Class support interface.

* ## What happens if you assign a struct to an interface variable?
  Boxing would take place. Here is the definition from MSDN.
  
  > Boxing is the process of converting a value type to the type object or to any interface type implemented by this value type
  
  A reference type function call always use "callvirt", which looks up virtual table for specific method, in IL. However, a value type function call use "call" which directly accesses method without vitrual table look-up. In order to support 
  table look-up, C# compiler boxes the value type to reference type. However, "box" doesn't make the value type into reference type. It just copies all the value from value type into an managed heap obejct and forces the reference type to refer to 
  that object. Hence, it is easy to cause bugs without caution. Here is an example.
  
  ```C#
  class Program
  {
      static void Main(string[] args)
      {
          Person Vic = new Person(28);
          
          IAgeAdder Adder = Vic;                                              // box
          Adder.Plus();                                                       // callvirt
          Console.WriteLine("Vic is " + Vic.ToString() + " years old");       // Vic is still the value type and the same as before
          Console.WriteLine("Adder is " + Adder + " years old");              // Adder refers to a temp object, generated by boxing
          Vic.Plus();                                                         // call
      }
  }

  struct Person : IAgeAdder
  {
      private int _age;

      public Person(int age)
      {
          _age = age;
      }

      public override string ToString()
      {
          return _age.ToString();
      }
      public void Plus() { ++_age; }
  }
  ```
  ```IL
  .method private hidebysig static void  Main(string[] args) cil managed
  {
    .entrypoint
    // 程式碼大小       89 (0x59)
    .maxstack  3
    .locals init (valuetype Mast.Person V_0,
             class Mast.IAgeAdder V_1)
    IL_0000:  nop
    IL_0001:  ldloca.s   V_0
    IL_0003:  ldc.i4.s   28
    IL_0005:  call       instance void Mast.Person::.ctor(int32)
    IL_000a:  ldloc.0
    IL_000b:  box        Mast.Person
    IL_0010:  stloc.1
    IL_0011:  ldloc.1
    IL_0012:  callvirt   instance void Mast.IAgeAdder::Plus()
    IL_0017:  nop
    IL_0018:  ldstr      "Vic is "
    IL_001d:  ldloca.s   V_0
    IL_001f:  constrained. Mast.Person
    IL_0025:  callvirt   instance string [System.Runtime]System.Object::ToString()
    IL_002a:  ldstr      " years old"
    IL_002f:  call       string [System.Runtime]System.String::Concat(string,
                                                                      string,
                                                                      string)
    IL_0034:  call       void [System.Console]System.Console::WriteLine(string)
    IL_0039:  nop
    IL_003a:  ldstr      "Adder is "
    IL_003f:  ldloc.1
    IL_0040:  ldstr      " years old"
    IL_0045:  call       string [System.Runtime]System.String::Concat(object,
                                                                      object,
                                                                      object)
    IL_004a:  call       void [System.Console]System.Console::WriteLine(string)
    IL_004f:  nop
    IL_0050:  ldloca.s   V_0
    IL_0052:  call       instance void Mast.Person::Plus()
    IL_0057:  nop
    IL_0058:  ret
  } // end of method Program::Main
  ```
* ## What’s different between abstract class and interface?

  Category                     | Interface  | Abstract Class| Class 
  -----------------------------|------------|---------------|------------------
  New                          | No         | No            | Yes   
  Constructor                  | No         | Yes           | Yes 
  Function                     | No         | Yes           | Yes 
  Abstract Function            | No         | Yes           | No
  Virtual Function             | No         | Yes           | Yes
  Interface                    | Yes        | No            | No
  Interface Inheritance        | Yes        | Yes           | Yes  
  Abstract Class Inheritance   | No         | Yes           | Yes
  Class Inheritance            | No         | Yes           | Yes
  
  ```C#
  class Person
  {
      public Person() { }                     // Ok constructor
      public void ConcreteWalk() { }          // OK concrete function
      //public abstract void AbstractWalk();  // compile error abstract function 
      public virtual void VirtualWalk() { }   // OK virtual function
      //void InterfaceWalk();                 // OK interfacce
  }

  abstract class PersonBase
  {
      public PersonBase() { }                 // OK constructor
      public void ConcreteWalk() { }          // OK concrete function
      public abstract void AbstractWalk();    // OK abstract function
      public virtual void VirtualWalk() { }   // OK vitural function
      //void InterfaceWalk();                 // OK interface 
  }

  interface IPerson
  {
      //IPerson()                             // compile error constructor
      //public void ConcreteWalk() { }        // compile error concrete function
      //public abstract void AbstractWalk();  // compile error abstract function
      //public virtual void VirtualWalk() { } // compile error virtual function
      void InterfaceWalk();                   // OK
  }  
  ```
  
  Let's look at each defintion in IL.
  ```IL
  .class public auto ansi beforefieldinit Mast.Person
       extends [System.Runtime]System.Object
  {
  } // end of class Mast.Person

  .class interface public abstract auto ansi Mast.IPerson
  {
  } // end of class Mast.IPerson

  .class public abstract auto ansi beforefieldinit Mast.PersonBase
       extends [System.Runtime]System.Object
  {
  } // end of class Mast.PersonBase
  ```
  
  You can find that interface has the attribute of abstract. Hence, you could think about interface is a subset of abstract class. Let's look at the function IL.
  
  ```IL
  .method public hidebysig newslot virtual 
        instance void  VirtualWalk() cil managed
  {
    // 程式碼大小       2 (0x2)
    .maxstack  8
    IL_0000:  nop
    IL_0001:  ret
  } // end of method Person::VirtualWalk
  
  .method public hidebysig newslot abstract virtual 
        instance void  InterfaceWalk() cil managed
  {
  } // end of method IPerson::InterfaceWalk
  
  .method public hidebysig newslot abstract virtual 
        instance void  AbstractWalk() cil managed
  {
  } // end of method PersonBase::AbstractWalk
  ```
  
  The functions in interface are all predefined abstract virtual, while in abstract class only abstract function is defined abstract virtual. Here is the conclusion. Interface is a subset of abstract class and is more constrained.
  1. Interface can't have construtor.
  2. Interface can't inherit other class, except interface.
  3. Interface force all funcions to be abstract virtual.
  
* ## What is the benefits brought by using StringBuilder instead of direct string concatenation?
  To show the idea, we could look at the container definition of each class first.
  
  ```C#
  [DefaultMember("Chars")]
  public sealed class StringBuilder : ISerializable
  {
      ...
      public char this[int index] { get; set; }
      ...
  }

  [DefaultMember("Chars")]
  public sealed class String : IEnumerable<char>, IEnumerable, IComparable, IComparable<String>, IConvertible, IEquatable<String>, ICloneable
  {
      ...
      public char this[int index] { get; }   
      ...
  }
  ```
  
  StringBuilder has accessor and mutator but string only has accessor. This leaves the clue that the author doesn't want any one to modify the value of string type. Let's keep look at the implmentation of funcions in class. I will take append as
  example. Note that in String class, there is only concat function.
  ```C#
  public unsafe StringBuilder Append(char* value, int valueCount)
  {
      // We don't check null value as this case will throw null reference exception anyway
      if (valueCount < 0)
      {
          throw new ArgumentOutOfRangeException("valueCount", Environment.GetResourceString("ArgumentOutOfRange_NegativeCount"));
      }

      // This case is so common we want to optimize for it heavily. 
      int newIndex = valueCount + m_ChunkLength;
      if (newIndex <= m_ChunkChars.Length)
      {
          ThreadSafeCopy(value, m_ChunkChars, m_ChunkLength, valueCount);
          m_ChunkLength = newIndex;
      }
      else
      {
          // Copy the first chunk
          int firstLength = m_ChunkChars.Length - m_ChunkLength;
          if (firstLength > 0)
          {
              ThreadSafeCopy(value, m_ChunkChars, m_ChunkLength, firstLength);
              m_ChunkLength = m_ChunkChars.Length;
          }

          // Expand the builder to add another chunk. 
          int restLength = valueCount - firstLength;
          ExpandByABlock(restLength);
          Contract.Assert(m_ChunkLength == 0, "Expand did not make a new block");

          // Copy the second chunk
          ThreadSafeCopy(value + firstLength, m_ChunkChars, 0, restLength);
          m_ChunkLength = restLength;
      }
      VerifyClassInvariant();
      return this;
  }  
  
  public static String Concat(String str0, String str1) {
      Contract.Ensures(Contract.Result<String>() != null);
      Contract.Ensures(Contract.Result<String>().Length ==
          (str0 == null ? 0 : str0.Length) +
          (str1 == null ? 0 : str1.Length));
      Contract.EndContractBlock();

      if (IsNullOrEmpty(str0)) {
          if (IsNullOrEmpty(str1)) {
              return String.Empty;
          }
          return str1;
      }

      if (IsNullOrEmpty(str1)) {
          return str0;
      }

      int str0Length = str0.Length;
      
      String result = FastAllocateString(str0Length + str1.Length);
      
      FillStringChecked(result, 0,        str0);
      FillStringChecked(result, str0Length, str1);
      
      return result;
  }  
  ```
  Comparing the return object, stringbuilder always return "this" while string always return "result", which is a temparty object. Any mutation to string would cause generation of new object. Stringbuilder only generates new object
  as long as full container. The design of string is to guaruntee it is a immutable object and hence, thread safe. To conclude, in order to save performance, if you would frequently mutate a string, it is recommanded to use string builder.
  If not, using string to guaruntee thread safe.
  
* ## What does IDisposable interface do?
* ## What’s the advantage / disadvantage between GC and reference counting?
* ## What’s the difference among Interpreter, Compiler, and JIT? What’s the pros and cons of JIT?
* ## Does delegate hold any reference?