# Week 3 C#
---
* ## What’s different between struct and class?

  Category                     | Struct    | Class 
  -----------------------------|-----------|-----------------------------------
  Parameterless Constructor    | No        | Yes 
  Type                         | Value     | Reference 
  Sealed                       | Default   | Optional 
  Abstract                     | No        | Yes
  Inheritance                  | Interface | Interface, Class, Abstract Class
  Dispose                      | No        | Yes
    
  1. Struct can't have explicit parameterless constrcutor.
  2. Struct is value type. Class is reference type.
  3. Struct can't be abstract. Class can be abstract.
  4. Struct is sealed type as default. Class can be delcared as sealed type.
  5. Struct can't inheritance. Class can inheritance.
  6. Struct can't dipose. Class can dipose.
  7. Struct support interface. Class support interface.

* ## What happens if you assign a struct to an interface variable?
  Boxing would take place. Here is the definition from MSDN.
  
  > Boxing is the process of converting a value type to the type object or to any interface type implemented by this value type
  
  A reference type function call always use "callvirt", which looks up virtual table for specific method, in IL. However, a value type function call use "call" which directly accesses method without vitrual table look-up. In order to support 
  table look-up, C# compiler boxes the value type to reference type. However, "box" doesn't make the value type into reference type. It just copies all the value from value type into an managed heap obejct and forces the reference type to refer to 
  that object. Hence, it is easy to cause bugs without caution. Here is an example.
  
  ```C#
  class Program
  {
      static void Main(string[] args)
      {
          Person Vic = new Person(28);
          
          IAgeAdder Adder = Vic;                                              // box
          Adder.Plus();                                                       // callvirt
          Console.WriteLine("Vic is " + Vic.ToString() + " years old");       // Vic is still the value type and the same as before
          Console.WriteLine("Adder is " + Adder + " years old");              // Adder refers to a temp object, generated by boxing
          Vic.Plus();                                                         // call
      }
  }

  struct Person : IAgeAdder
  {
      private int _age;

      public Person(int age)
      {
          _age = age;
      }

      public override string ToString()
      {
          return _age.ToString();
      }
      public void Plus() { ++_age; }
  }
  ```
  ```IL
  .method private hidebysig static void  Main(string[] args) cil managed
  {
    .entrypoint
    // 程式碼大小       89 (0x59)
    .maxstack  3
    .locals init (valuetype Mast.Person V_0,
             class Mast.IAgeAdder V_1)
    IL_0000:  nop
    IL_0001:  ldloca.s   V_0
    IL_0003:  ldc.i4.s   28
    IL_0005:  call       instance void Mast.Person::.ctor(int32)
    IL_000a:  ldloc.0
    IL_000b:  box        Mast.Person
    IL_0010:  stloc.1
    IL_0011:  ldloc.1
    IL_0012:  callvirt   instance void Mast.IAgeAdder::Plus()
    IL_0017:  nop
    IL_0018:  ldstr      "Vic is "
    IL_001d:  ldloca.s   V_0
    IL_001f:  constrained. Mast.Person
    IL_0025:  callvirt   instance string [System.Runtime]System.Object::ToString()
    IL_002a:  ldstr      " years old"
    IL_002f:  call       string [System.Runtime]System.String::Concat(string,
                                                                      string,
                                                                      string)
    IL_0034:  call       void [System.Console]System.Console::WriteLine(string)
    IL_0039:  nop
    IL_003a:  ldstr      "Adder is "
    IL_003f:  ldloc.1
    IL_0040:  ldstr      " years old"
    IL_0045:  call       string [System.Runtime]System.String::Concat(object,
                                                                      object,
                                                                      object)
    IL_004a:  call       void [System.Console]System.Console::WriteLine(string)
    IL_004f:  nop
    IL_0050:  ldloca.s   V_0
    IL_0052:  call       instance void Mast.Person::Plus()
    IL_0057:  nop
    IL_0058:  ret
  } // end of method Program::Main
  ```
* ## What’s different between abstract class and interface?

  Category                     | Interface  | Abstract Class| Class 
  -----------------------------|------------|---------------|------------------
  New                          | No         | No            | Yes   
  Constructor                  | No         | Yes           | Yes 
  Function                     | No         | Yes           | Yes 
  Abstract Function            | No         | Yes           | No
  Virtual Function             | No         | Yes           | Yes
  Interface                    | Yes        | No            | No
  Interface Inheritance        | Yes        | Yes           | Yes  
  Abstract Class Inheritance   | No         | Yes           | Yes
  Class Inheritance            | No         | Yes           | Yes
  
  ```C#
  class Person
  {
      public Person() { }                     // Ok constructor
      public void ConcreteWalk() { }          // OK concrete function
      //public abstract void AbstractWalk();  // compile error abstract function 
      public virtual void VirtualWalk() { }   // OK virtual function
      //void InterfaceWalk();                 // OK interfacce
  }

  abstract class PersonBase
  {
      public PersonBase() { }                 // OK constructor
      public void ConcreteWalk() { }          // OK concrete function
      public abstract void AbstractWalk();    // OK abstract function
      public virtual void VirtualWalk() { }   // OK vitural function
      //void InterfaceWalk();                 // OK interface 
  }

  interface IPerson
  {
      //IPerson()                             // compile error constructor
      //public void ConcreteWalk() { }        // compile error concrete function
      //public abstract void AbstractWalk();  // compile error abstract function
      //public virtual void VirtualWalk() { } // compile error virtual function
      void InterfaceWalk();                   // OK
  }  
  ```
  
  Let's look at each defintion in IL.
  ```IL
  .class public auto ansi beforefieldinit Mast.Person
       extends [System.Runtime]System.Object
  {
  } // end of class Mast.Person

  .class interface public abstract auto ansi Mast.IPerson
  {
  } // end of class Mast.IPerson

  .class public abstract auto ansi beforefieldinit Mast.PersonBase
       extends [System.Runtime]System.Object
  {
  } // end of class Mast.PersonBase
  ```
  
  You can find that interface has the attribute of abstract. Hence, you could think about interface is a subset of abstract class. Let's look at the function IL.
  
  ```IL
  .method public hidebysig newslot virtual 
        instance void  VirtualWalk() cil managed
  {
    // 程式碼大小       2 (0x2)
    .maxstack  8
    IL_0000:  nop
    IL_0001:  ret
  } // end of method Person::VirtualWalk
  
  .method public hidebysig newslot abstract virtual 
        instance void  InterfaceWalk() cil managed
  {
  } // end of method IPerson::InterfaceWalk
  
  .method public hidebysig newslot abstract virtual 
        instance void  AbstractWalk() cil managed
  {
  } // end of method PersonBase::AbstractWalk
  ```
  
  The functions in interface are all predefined abstract virtual, while in abstract class only abstract function is defined abstract virtual. Here is the conclusion. Interface is a subset of abstract class and is more constrained.
  1. Interface can't have construtor.
  2. Interface can't inherit other class, except interface.
  3. Interface force all funcions to be abstract virtual.
  
* ## What is the benefits brought by using StringBuilder instead of direct string concatenation?
  To show the idea, we could look at the container definition of each class first.
  
  ```C#
  [DefaultMember("Chars")]
  public sealed class StringBuilder : ISerializable
  {
      ...
      public char this[int index] { get; set; }
      ...
  }

  [DefaultMember("Chars")]
  public sealed class String : IEnumerable<char>, IEnumerable, IComparable, IComparable<String>, IConvertible, IEquatable<String>, ICloneable
  {
      ...
      public char this[int index] { get; }   
      ...
  }
  ```
  
  StringBuilder has accessor and mutator but string only has accessor. This leaves the clue that the author doesn't want any one to modify the value of string type. Let's keep look at the implmentation of funcions in class. I will take append as
  example. Note that in String class, there is only concat function.
  ```C#
  public unsafe StringBuilder Append(char* value, int valueCount)
  {
      // We don't check null value as this case will throw null reference exception anyway
      if (valueCount < 0)
      {
          throw new ArgumentOutOfRangeException("valueCount", Environment.GetResourceString("ArgumentOutOfRange_NegativeCount"));
      }

      // This case is so common we want to optimize for it heavily. 
      int newIndex = valueCount + m_ChunkLength;
      if (newIndex <= m_ChunkChars.Length)
      {
          ThreadSafeCopy(value, m_ChunkChars, m_ChunkLength, valueCount);
          m_ChunkLength = newIndex;
      }
      else
      {
          // Copy the first chunk
          int firstLength = m_ChunkChars.Length - m_ChunkLength;
          if (firstLength > 0)
          {
              ThreadSafeCopy(value, m_ChunkChars, m_ChunkLength, firstLength);
              m_ChunkLength = m_ChunkChars.Length;
          }

          // Expand the builder to add another chunk. 
          int restLength = valueCount - firstLength;
          ExpandByABlock(restLength);
          Contract.Assert(m_ChunkLength == 0, "Expand did not make a new block");

          // Copy the second chunk
          ThreadSafeCopy(value + firstLength, m_ChunkChars, 0, restLength);
          m_ChunkLength = restLength;
      }
      VerifyClassInvariant();
      return this;
  }  
  
  public static String Concat(String str0, String str1) {
      Contract.Ensures(Contract.Result<String>() != null);
      Contract.Ensures(Contract.Result<String>().Length ==
          (str0 == null ? 0 : str0.Length) +
          (str1 == null ? 0 : str1.Length));
      Contract.EndContractBlock();

      if (IsNullOrEmpty(str0)) {
          if (IsNullOrEmpty(str1)) {
              return String.Empty;
          }
          return str1;
      }

      if (IsNullOrEmpty(str1)) {
          return str0;
      }

      int str0Length = str0.Length;
      
      String result = FastAllocateString(str0Length + str1.Length);
      
      FillStringChecked(result, 0,        str0);
      FillStringChecked(result, str0Length, str1);
      
      return result;
  }  
  ```
  Comparing the return object, stringbuilder always return "this" while string always return "result", which is a temparty object. Any mutation to string would cause generation of new object. Stringbuilder only generates new object
  as long as full container. The design of string is to guaruntee it is a immutable object and thread safe. To conclude, in order to save performance, if you would frequently mutate a string, it is recommanded to use stringbuilder.
  If not, using string to guaruntee thread safe.
  
* ## What’s the advantage / disadvantage between GC and reference counting?
  I'd like to take Boehm Garbage Collection as example, since unity currently use this GC. To start with, GC is a central control system. You can image that that there is a guy who monitor your process intervally. When he looks at your 
  process, he stops the process. After that, he takes two step to finish the monitor. First, he checks if there is any resource dangling. Second, he deletes the dangling resource. This step is what we call "Mark and Sweep". In a GC system,
  every tiem when you new a heap object, it would be recorded. You could realize it as a tree. There would be many trees in a process. GC checks all the resource in memory and use DFS to search the tree. If
  any resource is not reachable, GC marks it as deletable. This process is called "Mark". Next, GC starts to delete all the resouces which are deletable. This process is called "Sweep". This is the basic idea of Boehm Garbage Collection.
  
  "Automatic Referency Counting" is another memory management system. It is quite a simple idea. Every objects has a default variable, reference count. Any time when a object is refered by others, the reference count would automatically increse.
  Any time when a object is not refered by others, the reference count decrease. As long as the reference count is zero, the object is destroyed immediately. 
  
  Here is the simple comparison between these two.
  
  Category                     | GC         | ARC    
  -----------------------------|------------|--------
  Process Memory Usage         | High       | Low         
  Thread Memory Usage          | Low        | Hgih
  Overall Performace           | Bad?       | Good?
  Application Performance      | Good       | Bad
  Retain Cycle                 | No         | Yes
  Realtime Destruction         | No         | Yes
  
  However, as the time passed by, there are more and more features implemented in GC and ARC. Take .Net 4.7 as example. It implements GC with generation and compacting. Generation is to help GC now the states or categories of the objects. For example, 
  long term object may be occupied in one specific generation while short term object is on the others. GC would handle different generation by different time in order to cost less resoucre. 
  
  ARC is processing, too. It mentained a "keyword" to handle retain cycle issue. However, it still needs engineers knowledge.
* ## What does IDisposable interface do?
  IDisposable and Finalizer has similar functionality. Both of them are used for releasing unmanaged heap. An unmanged heap contains file system, GUI+, COM object and ...etc. As we mentioned, GC is there to help us control managed heap. A process would not only have managed heap but also unmanaged heap. IDisposable and 
  Finalizer is to help GC handle with unmanaged heap. Here is how GC works from MSDN.
  1. The garbage collector searches for managed objects that are referenced in managed code.
  2. The garbage collector tries to finalize objects that are not referenced.
  3. The garbage collector frees objects that are not referenced and reclaims their memory.
  
  The interesting thing is when you finalize an unmanaged object, the memory is not reclaims immediately. The memory isn't reclaimed until next GC. It causes performacne overhead and unusage memory stuck for more time. In order to sovle the issue, 
  IDisposable is provided. In IDisposable, you could free the unmanged object and then suppress the finalization. Then, GC would reclaim the memory without waiting for finalization. The implmentation of IDisposible interface has become a pattern,
  dipose pattern, which is documented in MSDN. Here is the example.
  ```C#
  // base class demostratation
  class FileHelper : IDisposable
  {
      private bool _disposed = false;
      private int _offset = 0;
      private FileStream _file; // unmanaged object
      public FileHelper(string strPath)
      {
          _file = new FileStream(strPath, FileMode.OpenOrCreate);
      }

      ~FileHelper()  // finalizer as safe net
      {
          Dispose(false);
      }

      public void Write(string strInput)
      {
          _file.Write(Encoding.ASCII.GetBytes(strInput), 0, strInput.Length);
          _offset += strInput.Length;
      }

      public void Dispose()
      {
          Dispose(true);
          GC.SuppressFinalize(this);
      }

      protected virtual void Dispose(bool disposing)
      {
          if (_disposed) return;

          if (disposing)
          {
              // Free any manage objects here.
          }

          _file.Dispose(); // dipose unmanaged object

          _disposed = true;
      }
  }
  
  // derived class demonstration
  class DerivedFileHelper : FileHelper
  {
      bool _disposed = false;
      public DerivedFileHelper() : base(".\\DerivedFileHelper.txt") {}

      ~DerivedFileHelper() // finalizer as safe net
      {
          Dispose(false);
      }
      
      public void DWrite()
      {
          base.Write("Derived class is writing");
      }

      protected override void Dispose(bool disposing)
      {
          if (_disposed) return;

          if (disposing)
          {
              // Free any manage objects here.
          }

          _disposed = true;

          base.Dispose(disposing); // dipose base class object
      }
  }
  
  // Function call
  class Program
  {
      static void Main(string[] args)
      {
          using (DerivedFileHelper DFH = new DerivedFileHelper())
          {
              DFH.DWrite();
          }

          using (FileHelper FH = new FileHelper(".\\Filehelper.txt"))
          {
              FH.Write("FH is writing\r\n");
              FH.Write("FH is writing");
          }
      }
  }  
  ```
  
* ## What’s the difference among Interpreter, Compiler, and JIT? What’s the pros and cons of JIT?
* ## Does delegate hold any reference?