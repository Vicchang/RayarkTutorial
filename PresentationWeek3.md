# Week 3 C#
---
* ## What’s different between struct and class?

  Category                     | Struct    | Class 
  -----------------------------|-----------|-----------------------------------
  Parameterless Constructor    | No        | Yes 
  Type                         | Value     | Reference 
  Sealed                       | Default   | Optional 
  Abstract                     | No        | Yes
  Inheritance                  | Interface | Interface, Class, Abstract Class
  Dispose                      | No        | Yes
    
  1. Struct can't have explicit parameterless constrcutor.
  2. Struct is value type. Class is reference type.
  3. Struct can't be abstract. Class can be abstract.
  4. Struct is sealed type as default. Class can be delcared as sealed type.
  5. Struct can't inheritance. Class can inheritance.
  6. Struct can't dipose. Class can dipose.
  7. Struct support interface. Class support interface.

* ## What happens if you assign a struct to an interface variable?
  Boxing would take place. Here is the definition from MSDN.
  
  > Boxing is the process of converting a value type to the type object or to any interface type implemented by this value type
  
  A reference type function call always use "callvirt", which looks up virtual table for specific method, in IL. However, a value type function call use "call" which directly accesses method without vitrual table look-up. In order to support 
  table look-up, C# compiler boxes the value type to reference type. However, "box" doesn't make the value type into reference type. It just copies all the value from value type into an managed heap obejct and forces the reference type to refer to 
  that object. Hence, it is easy to cause bugs without caution. Here is an example.
  
  ```C#
  class Program
  {
      static void Main(string[] args)
      {
          Person Vic = new Person(28);
          
          IAgeAdder Adder = Vic;                                              // box
          Adder.Plus();                                                       // callvirt
          Console.WriteLine("Vic is " + Vic.ToString() + " years old");       // Vic is still the value type and the same as before
          Console.WriteLine("Adder is " + Adder + " years old");              // Adder refers to a temp object, generated by boxing
          Vic.Plus();                                                         // call
      }
  }

  struct Person : IAgeAdder
  {
      private int _age;

      public Person(int age)
      {
          _age = age;
      }

      public override string ToString()
      {
          return _age.ToString();
      }
      public void Plus() { ++_age; }
  }
  ```
  ```IL
  .method private hidebysig static void  Main(string[] args) cil managed
  {
    .entrypoint
    // 程式碼大小       89 (0x59)
    .maxstack  3
    .locals init (valuetype Mast.Person V_0,
             class Mast.IAgeAdder V_1)
    IL_0000:  nop
    IL_0001:  ldloca.s   V_0
    IL_0003:  ldc.i4.s   28
    IL_0005:  call       instance void Mast.Person::.ctor(int32)
    IL_000a:  ldloc.0
    IL_000b:  box        Mast.Person
    IL_0010:  stloc.1
    IL_0011:  ldloc.1
    IL_0012:  callvirt   instance void Mast.IAgeAdder::Plus()
    IL_0017:  nop
    IL_0018:  ldstr      "Vic is "
    IL_001d:  ldloca.s   V_0
    IL_001f:  constrained. Mast.Person
    IL_0025:  callvirt   instance string [System.Runtime]System.Object::ToString()
    IL_002a:  ldstr      " years old"
    IL_002f:  call       string [System.Runtime]System.String::Concat(string,
                                                                      string,
                                                                      string)
    IL_0034:  call       void [System.Console]System.Console::WriteLine(string)
    IL_0039:  nop
    IL_003a:  ldstr      "Adder is "
    IL_003f:  ldloc.1
    IL_0040:  ldstr      " years old"
    IL_0045:  call       string [System.Runtime]System.String::Concat(object,
                                                                      object,
                                                                      object)
    IL_004a:  call       void [System.Console]System.Console::WriteLine(string)
    IL_004f:  nop
    IL_0050:  ldloca.s   V_0
    IL_0052:  call       instance void Mast.Person::Plus()
    IL_0057:  nop
    IL_0058:  ret
  } // end of method Program::Main
  ```
* ## What’s different between abstract class and interface?

  Category                     | Interface  | Abstract Class| Class 
  -----------------------------|------------|---------------|------------------
  New                          | No         | No            | Yes   
  Constructor                  | No         | Yes           | Yes 
  Function                     | No         | Yes           | Yes 
  Abstract Function            | No         | Yes           | No
  Virtual Function             | No         | Yes           | Yes
  Interface                    | Yes        | No            | No
  Interface Inheritance        | Yes        | No            | No  
  Abstract Class Inheritance   | Yes        | Yes           | Yes
  Class Inheritance            | Yes        | Yes           | Yes
  
  ```C#
  class Person
  {
      public Person() { }                     // Ok constructor
      public void ConcreteWalk() { }          // OK concrete function
      //public abstract void AbstractWalk();  // compile error abstract function 
      public virtual void VirtualWalk() { }   // OK virtual function
      //void InterfaceWalk();                 // OK interfacce
  }

  abstract class PersonBase
  {
      public PersonBase() { }                 // OK constructor
      public void ConcreteWalk() { }          // OK concrete function
      public abstract void AbstractWalk();    // OK abstract function
      public virtual void VirtualWalk() { }   // OK vitural function
      //void InterfaceWalk();                 // OK interface 
  }

  interface IPerson
  {
      //IPerson()                             // compile error constructor
      //public void ConcreteWalk() { }        // compile error concrete function
      //public abstract void AbstractWalk();  // compile error abstract function
      //public virtual void VirtualWalk() { } // compile error virtual function
      void InterfaceWalk();                   // OK
  }  
  ```
  
  Let's look at each defintion in IL.
  ```IL
  .class public auto ansi beforefieldinit Mast.Person
       extends [System.Runtime]System.Object
  {
  } // end of class Mast.Person

  .class interface public abstract auto ansi Mast.IPerson
  {
  } // end of class Mast.IPerson

  .class public abstract auto ansi beforefieldinit Mast.PersonBase
       extends [System.Runtime]System.Object
  {
  } // end of class Mast.PersonBase
  ```
  
  You can find that interface has the attribute of abstract. Hence, you could think about interface is a subset of abstract class. Let's look at the function IL.
  
  ```IL
  .method public hidebysig newslot virtual 
        instance void  VirtualWalk() cil managed
  {
    // 程式碼大小       2 (0x2)
    .maxstack  8
    IL_0000:  nop
    IL_0001:  ret
  } // end of method Person::VirtualWalk
  
  .method public hidebysig newslot abstract virtual 
        instance void  InterfaceWalk() cil managed
  {
  } // end of method IPerson::InterfaceWalk
  
  .method public hidebysig newslot abstract virtual 
        instance void  AbstractWalk() cil managed
  {
  } // end of method PersonBase::AbstractWalk
  ```
  
  The functions in interface are all predefined abstract virtual, while in abstract class only abstract function is defined abstract virtual. Here is the conclusion. Interface is a subset of abstract class and is more constrained.
  1. Interface can't have construtor.
  2. Interface can't inherit other class, except interface.
  3. Interface force all funcions to be abstract virtual.
  
* ## What is the benefits brought by using StringBuilder instead of direct string concatenation?
* ## What does IDisposable interface do?
* ## What’s the advantage / disadvantage between GC and reference counting?
* ## What’s the difference among Interpreter, Compiler, and JIT? What’s the pros and cons of JIT?
* ## Does delegate hold any reference?